# -*- coding: utf-8 -*-
"""
Created on Sun Oct 14 23:31:49 2018

@author: hmelberg
"""

import copy
import pickle

#from rulebook.utils import *
from rulebook.utils import _listify, _expand_rulelist, _eval2cols, _expand_rules, _find_type, _insert_eval, _make_dict, _visualize,load_rulebook,suggest_rulebook


class OneRule():
   def __init__(self, text, name, group, func, args=None, action=None,
                action_args=None, etc=None):
       self.text = text,
       self.name = name,
       self.group = group,
       self.func = func,
       self.args = args,
       self.action = action,
       self.action_args = action_args,
       self.etc = etc


# %%
class RuleGroup():
   def __init__(self, rules, cols=None, name=None,
                description=None, action=None, comments=None, etc=None):
       self.rules = _listify(rules)
       self.cols = _listify(cols)
       self.name = name
       self.description = description
       self.action = action
       self.comments = comments
       self.etc = etc


# %%
class RuleBook():
   def __init__(self, rules=None):
       self.rulebook_list = list()
       self.comments = None,
       self.info = None,

   def add(self, rules, cols=None, name=None, description=None,
           action=None, comments=None, etc=None):
       """
       Adds a rule object (one or more rules) to the rulebook

       args:
           - rule (str, list of str): The name of the function determining valid observations
                   - can use inbuilt functions of self-defined functions
                   - can add arguments to functions in parenthesis, but must use keywords
                   - can use a list of one or more functions and columns: one or multiple rules can apply to one or more columns
                   - the function should return a series with 1 for valid rows and 0 for invalid rows (missing = invalid = false = 0)
           - cols (str, list of str): The column(s) where the rule(s) apply
                   - Single columns can be a str, and a comma seperated str is converted to a list with mupliple cols
           - name (str, optional): The rule can be assigned a name. if no name is assigned, one will e autogenerated (rule_1 etc)
           - description (str, optional): Describe rule in more detail
           - action (str, list of str): The name  of the function to be used  if rule is violated  (arguments in allowed in parenthesis)

       examples
           - add('is_int', 'age')
           - add(['is_int', 'is_positive'], ['age', 'days'])
           - add('length(max=5)', 'icd')

       """

       rule_group = RuleGroup(rules=rules, cols=cols, name=name, description=description,
                              action=action, comments=comments, etc=etc)

       # give the rule a name if no name is given
       if not rule_group.name:
           nrules = len(self.rulebook_list)
           proposed_name = 'rule_' + str(nrules + 1)
           existing_names = [rule.name for rule in self.rulebook_list]

           if proposed_name in existing_names:
               existing_nums = [int(name.split('_')[1]) for name in existing_names if
                                'rule_' in name]  # potentialproblem a name such as rule_no_negative
               max_num = max(existing_nums)
               proposed_name = 'rule_' + str(max_num + 1)
           rule_group.name = proposed_name

       # convert col to list if it is a string with , inside
       if rule_group.cols:
           if ',' in rule_group.cols:
               cols = rule.cols.split(',')
               cols = [strip(col) for col in cols]
               rule_group.cols = cols

       setattr(self, rule_group.name, rule_group)
       self.rulebook_list.append(rule_group)

   def add_many(self, rules):
       """
       add many rules to the rule object

       Note
           - Only works when column name is part of the expressions (ie. not with functions since functions also need to be assigned to columns)
           - Both a list and a comma separated string is ok

           add_many('age>18, birth_year>1970')
           add_many(['age>18', 'birth_year>1970'])
       """

       if isinstance(rules, str):
           rules = rules.split(',')
       for rule in rules:
           self.add(rule=rule)

   def delete(self, rules):
       if isinstance(rules, str): rules = set([rules])
       keep_rules = [rule for rule in self.rules if rule.name not in rules]
       self.rules = keep_rules

   def append_col(self, name, cols):
       cols = listify_cols
       modified_rules = []
       for rule in self.rulebook_list:  # rulebook_lilst should be private  .. and called sth else
           if rule.name == name:
               rule.cols.extend(cols)
           modified_rules.append(rule)
       return modified_rules

   def drop_col(self, name, cols):
       cols = listify_cols
       modified_rules = []
       for rule in self.rulebook_list:  # rulebook_lilst should be private  .. and called sth else
           if rule.name == name:
               existing_cols = rule.cols
               keep_cols = existing_cols - set(cols)
               rule.cols = keep_cols
           modified_rules.append(rule)
       return modified_rules

   def view(self, rules=None):
       if not rules: rules = self.rulebook_list
       for rule in rules:
           print(rule.name, rule.rules)

   def view_cols(self, cols=None, rules=None):
       self._fix_format()

       if not rules: rules = self.rulebook_list

       col_rules = {}
       for rule in rules:
           for col in rule.cols:
               if (not cols) or (cols in rule.cols):
                   if col in col_rules:
                       col_rules[col].append(rule)
                   else:
                       col_rules[col] = [rule]

       for col, rules in col_rules.items():
           for rule in rules:
               print(col, rule.name, rule.rule)

   def save(self, file):
       with open(file, 'wb') as output:
           pickle.dump(self, output, protocol=0)
           # pickle.HIGHEST_PROTOCOL

   def _check(self, df, rules=None, cols=None, change=False, out='check'):

       # use all or only some rules
       all_rules = set(self.rulebook_list)
       all_names = set([rule.name for rule in all_rules])

       if rules:
           specified_names = set(_listify(rules))
           subset_names = all_names.intersection(specified_names)
       else:
           subset_names = all_names

       subset_rules = [rule for rule in all_rules if rule.name in subset_names]

       # use all or only some columns
       if cols:
           subset_rules = copy.deepcopy(subset_rules)
           include_cols = set(cols)

           for rule in subset_rules:
               existing_cols = set(rule.cols)
               new_cols = existing_cols.intersection(include_cols)
               rule.cols = list(new_cols)

       # same rule(s) may apply to many column(s), so make
       # separate rule for each combination
       expanded_rules = _expand_rulelist(subset_rules)

       # dictionary to save info from check
       result = {}

       for rule in expanded_rules:
           ok = globals()[rule.func[0]](df=df, **rule.args[0])  # hmmm why are these tuples?)

           if rule.args[0]['col']:
               col = rule.args[0]['col']
               name = f"{rule.name}_col{col}"

               result[name] = dict()
               result[name]['ok'] = ok
               result[name]['nans'] = df[col].isnull().sum()
               result[name]['ninvalid'] = (~ok).sum()
               result[name]['values'] = df[col][~ok].values
               result[name]['series'] = df[col][~ok]
               result[name]['df'] = df[~ok]
           else:
               result[rule.name] = dict()

               result[name]['ok'] = ok
               result[name]['nans'] = ok.isnull().sum()
               result[name]['ninvalid'] = (~ok).sum()
               result[name]['df'] = df[~ok]

           # change the column(s)
           if change and rule.action:
               try:
                   new_df = globals()[rule.action[0]](df=df, ok=ok, **rule.action_args[0])
               except:
                   print(f"Error for rule {rule.name, rule.text}")

       if out == 'check':
           for name, res in result.items():
               print(name, res['ninvalid'], res['nans'])
           return result
           # return fails

       elif out == 'change':
           return new_df
       elif out == 'check_and_change':
           return result, df
       else:
           print('out argument is wrong')
       return

   def check(self, df, rules=None, cols=None):
       results_out = self._check(df=df, rules=rules, cols=cols, out='check')
       return results_out

   def change(self, df, rules=None, cols=None):
       changed_df = self._check(df=df, rules=rules, cols=cols, out='change', change=True)
       return changed_df

   def check_change_check(self, df, rules=None, cols=None):
       df_with_fails_before = self._check(df=df, rules=rules, cols=cols)
       changed_df = self._check(df=df, rules=rules, cols=cols, out='change')
       df_with_fails_after = self._check(df=changed_df, rules=rules, cols=cols)
       return changed_df, df_with_fails_before, df_with_fails_after









